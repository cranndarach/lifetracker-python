---
title: "Spoons vs. Time"
author: "Rachael Steiner"
date: "August 26, 2016"
output: html_document
---

```{r 'init'}
require(plyr)
require(knitr)
source("lifetracker_functions.R")
# Edit file path as needed
d <- read.csv("2016-09-15.csv", stringsAsFactors = F)
```

```{r}
day <- d[ , c("when_hour", "when_minute", "when_ampm", "spoons", "start_hour", 
           "start_minute", "start_ampm", "start_spoons", "end_hour", "end_minute", 
           "end_ampm", "end_spoons")]
# Convert to 24-hour, and to proportions
day$when_hour24 <- h24(day$when_hour, day$when_ampm)
day$when_hprop <- hourprop(day$when_hour24, day$when_minute)
day$start_hour24 <- h24(day$start_hour, day$start_ampm)
day$start_hprop <- hourprop(day$start_hour24, day$start_minute)
day$end_hour24 <- h24(day$end_hour, day$end_ampm)
day$end_hprop <- hourprop(day$end_hour24, day$end_minute)

# vectors for time, and corresponding vectors for spoons
combo.time <- c(day$start_hprop, day$end_hprop, day$when_hprop)
combo.spoons <- c(day$start_spoons, day$end_spoons, day$spoons)
# Make into a data frame, and clean:
# Remove NAs and valence=0 (or no data)
combo <- data.frame("Time"=combo.time, "Spoons"=combo.spoons)
combo <- combo[!is.na(combo$Time) & !is.na(combo$Spoons), ]
combo <- combo[order(combo$Time), ]
combo <- combo[combo$Spoons != 0, ]
```

```{r}
# plot it
plot(combo$Time, combo$Spoons, xlab="Time of Day", ylab="Spoons", main="Spoons with respect to time of day", col="plum3", lwd=3)

# see if there's a trend
spoons.lm <- lm(Spoons ~ Time, combo)
abline(spoons.lm, col="navyblue", lwd=2)
summary(spoons.lm)

# what about from morning on?
daytime <- ifelse(combo$Time < 6, combo$Time + 24, combo$Time)
spoons.awake.lm <- lm(combo$Spoons ~ daytime)
abline(spoons.awake.lm, col="darkgreen", lwd=2)
summary(spoons.awake.lm)
```

Time passed since waking up? Mod by how much sleep?

```{r}
# sleepcols <- grep("sleep", names(d))
# sleep <- d[, sleepcols]
# d$sleep_start_h24 <- h24(d$sleep_start_hour, d$sleep_start_ampm) #h24 is contained in hprop
# d$sleep_end_h24 <- h24(d$sleep_end_hour, d$sleep_end_ampm)
day$s_start_hprop <- hprop(d$sleep_start_hour, d$sleep_start_minute, d$sleep_start_ampm)
day$s_end_hprop <- hprop(d$sleep_end_hour, d$sleep_end_minute, d$sleep_end_ampm)
# d$s_end_hprop <- ifelse(d$s_end_hprop == 19.716667, 7.716667, d$s_end_hprop)
day$s_duration <- ifelse(day$s_end_hprop > day$s_start_hprop, day$s_end_hprop - day$s_start_hprop, (day$s_end_hprop + 24) - day$s_start_hprop)
```

```{r}
makedate <- function(m,d,y){
  return(paste(m,d,y, sep="/"))
}
day$start_date <- makedate(d$start_month, d$start_day, d$start_year)
day$end_date <- makedate(d$end_month, d$end_day, d$end_year)
day$sleep_date <- makedate(d$sleep_end_month, d$sleep_end_day, d$sleep_end_year)
day$when_date <- makedate(d$when_month, d$when_day, d$when_year)

day$date <- rep(NA, dim(day)[1])
day$date <- ifelse(day$end_date != "NA/NA/NA", day$end_date, 
                 ifelse(day$when_date != "NA/NA/NA", day$when_date, 
                        ifelse(day$sleep_date != "NA/NA/NA", day$sleep_date, day$date)))

# Sleep duration as a factor
sleepdate <- day[!(is.na(day$s_duration)), c("date", "s_duration")]
day <- join(day, sleepdate, by="date")
names(day)[length(names(day))] <- "sleepdur"
```

```{r}
# day$date <- d$date
# day$s_duration <- d[,98] # d$s_duration wasn't working
combo <- data.frame("Time"=combo.time, "Spoons"=combo.spoons, "Sleep"=rep(day$sleepdur, 3)) #c(day$s_duration, day$s_duration, day$s_duration))
combo <- combo[!is.na(combo$Time) & !is.na(combo$Spoons) & !is.na(combo$Sleep), ]
combo <- combo[order(combo$Time), ]
combo <- combo[combo$Spoons != 0, ]
# If it's before 6 am, add 24 hrs because it's probably the day before
combo$Time <- ifelse(combo$Time < 6, combo$Time + 24, combo$Time)

spoons.lm.1 <- lm(Spoons ~ Time, combo) # Time of day
spoons.sleep <- lm(Spoons ~ Time/Sleep, combo) # Time of day + Time wrt amount of sleep
kable(anova(spoons.lm.1, spoons.sleep))
delta.r2 <- summary(spoons.sleep)$r.squared - summary(spoons.lm.1)$r.squared

# summary(spoons.lm.1)
# summary(spoons.sleep)

# coefs <- summary(spoons.sleep)$coefficients[,1]
# m.sleep <- mean(combo$Sleep)
# l.sleep <- m.sleep - sd(combo$Sleep)
# h.sleep <- m.sleep + sd(combo$Sleep)
# idk i'll do this when i've slept and it's earlier

```

```{r}
wakeup <- day[!(is.na(day$s_end_hprop)), c("date", "s_end_hprop")]
day <- join(day, wakeup, by="date")
# day$when_hprop <- day$when_hprop
# day$end_hprop <- day$end_hprop

names(day)[length(names(day))] <- "wakeup"
day$when <- ifelse(!(is.na(day$when_hprop)), day$when_hprop,
                 ifelse(!is.na(day$end_hprop), day$end_hprop, NA))
day$since_wakeup <- day$when - day$wakeup
```

```{r}
combo <- data.frame("Time"=combo.time, "Spoons"=combo.spoons, "Sleep"=rep(day$sleepdur, 3),
                    "SinceWakeup"=rep(day$since_wakeup, 3))
combo <- combo[!is.na(combo$Time) & !is.na(combo$Spoons) & !is.na(combo$Sleep), ]
combo <- combo[order(combo$Time), ]
combo <- combo[combo$Spoons != 0, ]
combo <- combo[combo$SinceWakeup > 0, ]
combo$Time <- ifelse(combo$Time < 6, combo$Time + 24, combo$Time)

spoons.wakeup.m1 <- lm(Spoons ~ SinceWakeup, combo)
spoons.wakeup.m2 <- update(spoons.wakeup.m1, ~ . + SinceWakeup/Sleep)
kable(anova(spoons.wakeup.m1, spoons.wakeup.m2))
summary(spoons.wakeup.m2)
```

```{r}
###---------------------------------------------------------------------###
###                 FUTURE RACHAEL, LOOK AT THIS                        ###
### THIS IS HOW YOU GET THE COEFFICIENTS WITHOUT RISKING COPYING ERROR  ###
###---------------------------------------------------------------------###
names(summary(spoons.wakeup.m2)) # "coefficients" looks very promising
summary(spoons.wakeup.m2)$"coefficients"
# returns a nice little table-like object! 
# btw, it's "class()", not "type()" like I always think because type makes plenty of sense:
class(summary(spoons.wakeup.m2)$"coefficients") # matrix
coefmat <- summary(spoons.wakeup.m2)$"coefficients"
dimnames(coefmat) # there we go
# can the estimates be made into one nice vector?
ests <- coefmat[,1]
ests # nice!!
# they have names and everything. perfect.
###----------------------------------------------###
###--------------------END-----------------------###
###----------------------------------------------###

# let's apply it
b.t <- ests["SinceWakeup"]
# b.jp <- ests["jp.c"]
b.int <- ests["SinceWakeup:Sleep"]
a <- ests[1]

# treat job performance as the moderator
# points include the mean (0), and +/- 1 sd
low.slp <- -sd(combo$Sleep)
high.slp <- sd(combo$Sleep)
mid.slp <- mean(combo$Sleep) # to be thorough

# from now on, ws will be treated as x1; jp as x2
# I just want to be able to see it
# b1 <- b.ws
# b2 <- b.jp
# b3 <- b.int

# intercept in simple slopes analysis: a + b2*x2
low.a <- a + low.slp
high.a <- a + high.slp
mid.a <- a

# b in simple slopes: b1 + b3x2
low.b <- b.t + b.int*low.slp
high.b <- b.t + b.int*high.slp
mid.b <- b.t
```






